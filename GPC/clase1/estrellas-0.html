<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Ejemplo Estrellas</title>
    <style>
        body { 
            background-color: grey; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0;
        }
        canvas { 
            background-color: white; 
            border: 1px solid black; 
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="1200" height="600"></canvas>

    <script>
	
		// En este ejemplo agregamos una variable global tiempo, que se la pasamos al vertex shader
		
        window.onload = function() {
            // 1. Obtener el contexto WebGL
            var canvas = document.getElementById("myCanvas");
            var gl = canvas.getContext("webgl");

            if (!gl) {
                alert("Error: Tu navegador no soporta WebGL.");
                return;
            }

            // 2. Definir los shaders
			// Agregar un nuevo atributo para los colores de los vértices y pasar ese valor al fragment shader usando varying.
			var vertexShaderSource = `
				attribute vec2 a_position;
				attribute vec3 a_color;
				varying vec3 v_color;
				uniform float u_time;		// Agrego una variable uniforme
				void main() {
					
					gl_Position = vec4(a_position, 0.0, 1.0);
					gl_PointSize = 5.0;
					v_color = a_color;
				}
			`;

			// Recibir el color interpolado desde el vertex shader y usarlo para definir el color del fragmento.
			var fragmentShaderSource = `
				precision mediump float;
				varying vec3 v_color;
				void main() {
					// Coordenadas de los puntos en el rango [-1, 1]
					vec2 coord = gl_PointCoord * 2.0 - 1.0;
                    float k = 1.0;
					//gl_FragColor = vec4(k,k,k, 1.0);
                    gl_FragColor = vec4(v_color, 1.0);
				}				
				
				
			`;

            // 3. Crear y compilar los shaders
            function createShader(gl, type, source) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error("Error al compilar el shader:", gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            // 4. Crear el programa y enlazar los shaders
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Error al enlazar el programa:", gl.getProgramInfoLog(program));
                return;
            }
            gl.useProgram(program);

			// 5. Definir N y generar los datos de los vértices aleatoriamente
			var N = 1000;  // Puedes cambiar N para generar más vértices

			// Crear un array para las posiciones de los vértices
			var positions = new Float32Array(N * 2); // N vértices, cada uno con 2 coordenadas (x, y)

			// Crear un array para los colores de los vértices
			var colors = new Float32Array(N * 3); // N vértices, cada uno con 3 componentes de color (r, g, b)

			// Generar los vértices con posiciones aleatorias entre -1 y 1
			for (var i = 0; i < N; i++) {
				// Posiciones al azar entre -1 y 1
				positions[i * 2] = Math.random() * 2 - 1;    // x
				positions[i * 2 + 1] = Math.random() * 2 - 1; // y

				// Colores al azar entre 0 y 1
            colors[i * 3] = Math.random();     // r
				colors[i * 3 + 1] = Math.random(); // g
				colors[i * 3 + 2] = Math.random(); // b
			}


			// 6. Crear un buffer y pasarle los datos

			// Crea un nuevo buffer en la GPU.
			// Un buffer es una porción de memoria que la GPU utilizará para almacenar datos, como las posiciones de los vértices.
			var positionBuffer = gl.createBuffer(); 
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW); 
			var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
			gl.enableVertexAttribArray(positionAttributeLocation);
			gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);


			// idem para buffer de colores
            var colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
			
            var colorAttributeLocation = gl.getAttribLocation(program, "a_color");
            gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(colorAttributeLocation);			
			
			// 2. Obtener la ubicación del uniform `u_time`
            var timeUniformLocation = gl.getUniformLocation(program, "u_time");		
			
			// variable global cantidad de vertices
			cant_V = N;

			// Como la escena ahora es dinámica debido a la animación, no podemos simplemente dibujar una vez y listo.
			// Para manejar este problema, definimos una función de renderizado que se llamará en cada frame utilizando `requestAnimationFrame`.
			// Esto nos permite actualizar el tiempo en cada frame, recalcular las posiciones de los vértices en el shader,
			// y redibujar la escena continuamente, creando la animación.
			
			
			//Función de renderizado
			// La función de renderizado recibe el tiempo transcurrido (elapsed time) desde que comenzó la animación,
			// lo que permite calcular el valor de `u_time` en segundos. Este valor se pasa al shader para animar la posición del triángulo.
			// En cada llamada a la función, se limpia la pantalla, se actualiza la posición del triángulo según el tiempo,
			// y se vuelve a dibujar la escena. Al final de la función, `requestAnimationFrame` vuelve a llamar a `render`,
			// lo que crea un loop de animación continuo.
			
            function render(time) {
                // Convertir el tiempo de milisegundos a segundos
                var timeInSeconds = time * 0.001;
                
                // Establecer el valor del uniform `u_time`
                gl.uniform1f(timeUniformLocation, timeInSeconds);

                // Limpiar la pantalla y dibujar el triángulo
                gl.clearColor(0.0, 0.0, 0.0, 1.0); // Negro
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.POINTS, 0, cant_V);

                // Volver a llamar a `render` en el siguiente frame
                requestAnimationFrame(render);
            }			
			
			// Iniciar la animación
			//requestAnimationFrame le dice al navegador que deseas realizar una animación, 
			// y solicita que el navegador ejecute una función específica para actualizar la animación antes del próximo 
			//repintado de la pantalla. Esto asegura que la animación sea lo más suave posible, sincronizándose con la tasa de refresco 
			// del monitor (normalmente 60Hz).
            requestAnimationFrame(render);

        };
    </script>
</body>
</html>
